<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
    <a href="index.html">index</a>
</div>
<hr>
<h1 id="langext">LangExt</h1>
<p>これは、LangExtの概要を説明するドキュメントです。</p>
<h2 id="用語">用語</h2>
<p>このドキュメントおよびLangExtで使用する用語の説明です。</p>
<h3 id="関数">関数</h3>
<p>staticメソッドやラムダ式、デリゲートを単に「関数」と記述しています。 他にも、関数を引数に取るようなメソッドや、関数を返すようなメソッドのことを「高階関数」と記述します。</p>
<h3 id="モジュール">モジュール</h3>
<p>staticクラスのことをモジュールと記述しています。</p>
<p>LangExtが提供するジェネリック型に対しては、同名のモジュールに拡張メソッドを含む関数を定義します。 例えば、ジェネリック型のOption型に対するモジュールの名前はOptionです。<br />それに対して、LangExtが提供する非ジェネリック型には、型名の後ろに「Module」というサフィックスを付けたモジュール名を使います。 例えば、非ジェネリック型のUnit型に対するモジュールの名前はUnitModuleです。</p>
<p>LangExt以外で提供される型に対する関数の定義は、ジェネリック型と同名の非ジェネリック型を持たない型と、それ以外の型で扱いが異なります。 ジェネリック型と同名の非ジェネリック型を持たない型の場合、ジェネリック型と同名のモジュールに拡張メソッドを含む関数を定義します。 例えば、<code>System.Func</code>などがこれに該当し、Funcモジュールに関数を定義しています。 それに対して、ジェネリック型と同名の非ジェネリックを持つ型、あるいは非ジェネリック型の場合、 型名の後ろに「Module」というサフィックスを付けたモジュール名を使います。 例えば、<code>System.Tuple</code>などがこれに該当し、TupleModuleモジュールに関数を定義しています。</p>
<table>
<thead>
<tr class="header">
<th align="left">型の定義場所</th>
<th align="center">型パラメータ</th>
<th align="center">型パラメータなしの型の有無</th>
<th align="left">モジュール名</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">LangExt</td>
<td align="center">有</td>
<td align="center">-</td>
<td align="left">型名と同名</td>
</tr>
<tr class="even">
<td align="left">LangExt</td>
<td align="center">無</td>
<td align="center">-</td>
<td align="left">型名 + Module</td>
</tr>
<tr class="odd">
<td align="left">LangExt以外</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="left">型名 + Module</td>
</tr>
<tr class="even">
<td align="left">LangExt以外</td>
<td align="center">有</td>
<td align="center">無</td>
<td align="left">型名と同名</td>
</tr>
<tr class="odd">
<td align="left">LangExt以外</td>
<td align="center">無</td>
<td align="center">-</td>
<td align="left">型名 + Module</td>
</tr>
</tbody>
</table>
<p>また、インターフェイスに対するモジュールの場合、Iプレフィックスを取り除いた名前を使います。 例えば、<code>System.Collections.Generic.IEnumerable</code>などがこれに該当し、Enumerableモジュールに関数を定義しています。</p>
<h3 id="型">型</h3>
<p>モジュール以外のクラスや、構造体、列挙型などをまとめて、型と記述しています。</p>
<h3 id="シーケンス">シーケンス</h3>
<p><code>Seq[T]</code>のことを、シーケンスと呼びます。 LangExtではLINQ to Objectsを捨て、シーケンスに対して「より関数プログラミングの語彙に近いAPI」を再構築しています。 その際に、<code>IEnumerable[T]</code>ではなく、<code>Seq[T]</code>を操作の対象に選んだため、配列との統一的なAPIは諦めています。 しかし、オーバーロードを極力排除したことにより、LINQ to Objectsよりも拡張の幅が大きくなっています。 また、LINQ to Objectsより多くの操作を提供しているため、LINQ to Objectでは実現できなかった表現力を備えています。</p>
<h2 id="表記">表記</h2>
<p>このドキュメントおよびLangExtで使用する表記の説明です。</p>
<h3 id="関数の型">関数の型</h3>
<p>関数の型は、</p>
<pre class="sourceCode cs"><code class="sourceCode cs">(<span class="dt">int</span>, <span class="dt">int</span>) → <span class="dt">int</span></code></pre>
<p>のように、引数の型と戻り値の型を<code>→</code>で区切った形式で記述します。 上の例は、intを2つ受け取ってintを返す関数です。 引数が1つの場合は、引数を囲むかっこを省略します。</p>
<p>Funcデリゲートの型も同様に、引数の型と戻り値の型を<code>→</code>で区切って表しますが、全体をかっこで囲みます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs">(<span class="dt">int</span> → <span class="dt">int</span>)</code></pre>
<p>これは、intを受け取ってintを返すFuncデリゲートを表します。 Actionデリゲートは、戻り値の型としてvoidを指定します。 例えば<code>(int → void)</code>は、intを受け取るActionデリゲートを表します。</p>
<h3 id="ジェネリック型">ジェネリック型</h3>
<p>ジェネリック型は、</p>
<pre class="sourceCode cs"><code class="sourceCode cs">Option[T]</code></pre>
<p>のように角かっこを用います。 これは、ドキュメンテーションコメントの可読性を考慮した結果です。</p>
<h3 id="型パラメータ">型パラメータ</h3>
<p>型パラメータは、Tから始まる一文字の大文字(T, U, V, ...)で記述します。 例えば、Tを受け取ってTを返す関数は、</p>
<pre class="sourceCode cs"><code class="sourceCode cs">T → T</code></pre>
<p>です。 これに続けて、番号を付ける場合もあります(T1, T2, ...)。</p>
<p>型パラメータに明確な意味があるような場合、Tに続けて意味を表す語を続けます。 例えば、成功の場合の型をTSuccessとして表し、失敗の場合の型をTFailureとして表したりします。</p>
<h3 id="タプル">タプル</h3>
<p>タプルの型は、各要素の型をアスタリスクで連結して記述します。 例えば、T1とT2のタプルの型は、</p>
<pre class="sourceCode cs"><code class="sourceCode cs">T1 * T2</code></pre>
<p>です。 タプルを受け取る関数(タプル関数)と複数引数の関数は、以下のように区別されます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs">T1 * T2 → U
(T1, T2) → U</code></pre>
<h3 id="choice">Choice</h3>
<p>Choice(択一)の型は、各要素の型を+で連結して記述します。 例えば、T1とT2のChoiceの型は、</p>
<pre class="sourceCode cs"><code class="sourceCode cs">T1 + T2</code></pre>
<p>です。</p>
<h3 id="シーケンス-1">シーケンス</h3>
<p>波かっこの中にカンマ区切りで要素を列挙することで、シーケンスの値を表します。 例えば、要素として1～3の整数を含むシーケンスは、</p>
<pre class="sourceCode cs"><code class="sourceCode cs">{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> }</code></pre>
<p>と表記します。</p>
<h2 id="langextが提供する主な型とモジュール">LangExtが提供する主な型とモジュール</h2>
<p>LangExtが提供する主な型とモジュールについて、その役割や意味を簡単に説明します。 実際の使い方に関しては、ドキュメンテーションコメント等を参考にしてください。</p>
<h3 id="placeholder型">Placeholder型</h3>
<p>Placeholder型は、プレースホルダーとして使用されることを前提とした型です。</p>
<p>この型をユーザが明示的に使用することはありません。 この型は、Option型を型パラメータを指定せずに生成したりするために使用されます。 基本的には暗黙の型変換のために使用されますが、具体的な使用例はOption型などを参照してください。</p>
<p>この型の値に意味はないため、列挙子を持たない列挙型として実装されています。 数値をキャストすることでこの型の値を作ることはできますが、そうした場合の動作は保証しませんので注意してください。</p>
<h3 id="unit型">Unit型</h3>
<p>Unit型は、意味を持つ値がないことを表すための型です(0bitの情報を持つ型とも言えるでしょう)。 この型はフィールドを一つも持たない構造体として実装されています。</p>
<p>voidとの違いは、voidは値がないうえに、型パラメータとして使用することができないのに対して、Unit型はそうではないという点です。 値がない場合とある場合を共通化したい場合、Unit型が使用できます。</p>
<p>Ignore関数を使うことによって、任意の型の値をUnit型に変換する(捨てる)ことが可能です。</p>
<h3 id="option型">Option型</h3>
<p>Option型は、失敗しうる計算の結果として使用できる型です。 この型は、nullを使うよりも安全に「値がないこと」を表せます。</p>
<p>nullはコンパイラによってnullチェックを強制できないため、プログラマが必要な場所にnullチェックを埋め込む必要があります。 これに漏れがあると、NullReferenceExceptionが発生するバグとなります。 この問題の根本には、nullが入りうる型Tの値tに対して、nullが入っていようがいまいが関係なくTの持つメンバーにアクセスできてしまうという問題があります。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">int</span> <span class="fu">F</span>(<span class="dt">string</span> str)
{
    <span class="co">// strにnullが入っていてもいなくても、strのメソッドは呼べてしまう</span>
    <span class="co">// (少なくとも、コンパイルが通ってしまう)</span>
    <span class="kw">return</span> str.<span class="fu">IndexOf</span>(<span class="st">&quot;a&quot;</span>);
}</code></pre>
<p>それに対して、Option型はTをラップする型なので、Tの持つメンバーに直接アクセスすることは出来ません。</p>
<pre class="sourceCode cs"><code class="sourceCode cs">Option&lt;<span class="dt">int</span>&gt; <span class="fu">F</span>(Option&lt;<span class="dt">string</span>&gt; opt)
{
    <span class="co">// optはstringではないため、stringのメソッドであるIndexOfは呼び出せない</span>
    <span class="co">//return opt.IndexOf(&quot;a&quot;);</span>
    <span class="co">// Mapに渡す関数は、値がある場合(Someの場合)だけ呼び出され、strはnullではないことが保証されている</span>
    <span class="co">// 値がない場合(Noneの場合)は、何も行わずにそのままNoneが返される</span>
    <span class="kw">return</span> opt.<span class="fu">Map</span>(str =&gt; str.<span class="fu">IndexOf</span>(<span class="st">&quot;a&quot;</span>));
}</code></pre>
<p>いったんOption型でラップしたものからOption型をはぎ取るためには、「値がない場合」の考慮をAPIによって強制されます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> resOpt = <span class="fu">F</span>(opt); <span class="co">// 先ほどのFを呼び出す</span>
<span class="co">// MatchでOptionをはぎ取ることができるが・・・</span>
<span class="dt">var</span> res = resOpt.<span class="fu">Match</span>(
    Some: v =&gt; v,    <span class="co">// 値がある場合と</span>
    None: () =&gt; -<span class="dv">1</span>); <span class="co">// ない場合を考慮する必要がある</span>

<span class="co">// GetOrでも中の値を取得できるが、やはり値がなかった場合の考慮が必要</span>
<span class="co">//var res = resOpt.GetOr(-1);</span></code></pre>
<p>このように、Option型はnullよりも安全に「値がない」ことを扱えます<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>。</p>
<p>nullを使うのではなく、契約プログラミングによって(Code Contractなどを使って)nullを排除する方向はどうでしょうか。 これはこれで重要なことではあるのですが、値がないことを表す必要が出た場合にどうするのか、という問題が起きます。 その際に、nullではなく、Option型を使えばいいのです。</p>
<p>値がない可能性の一番身近な例としては、文字列のパースがあります。 例えば、<code>int.Parse</code>はintとして不正な文字列が渡されると、例外を投げます。 これを避けるために、出力引数を使ったバージョンである<code>int.TryParse</code>が用意されていますが、 出力引数は結果格納用が必要で、使うのは面倒です。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">int</span> result;
<span class="kw">if</span> (<span class="dt">int</span>.<span class="fu">TryParse</span>(str, <span class="kw">out</span> result))
{
    <span class="co">// Parseに成功した場合の処理</span>
}
<span class="kw">else</span>
{
    <span class="co">// Parseに失敗した場合の処理</span>
}</code></pre>
<p>これに対してOption型は、その必要がありません。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="co">// LangExtにはTryToIntは用意されていないが、簡単に定義できる</span>
str.<span class="fu">TryToInt</span>().<span class="fu">Match</span>(
    Some: result =&gt; <span class="co">/* 変換に成功した場合の式 */</span>,
    None: () =&gt; <span class="co">/* 変換に失敗した場合の式 */</span>);</code></pre>
<p>boolを返す出力引数を取る関数が使いたくなった場合は、立ち止まってOption型で置き換えれないかを考えましょう。 出力引数が1つしかない場合は簡単に置き換え可能です。 出力引数が複数ある場合、特にstring型やint型といった基本的な型を複数出力引数に指定するのはアンチパターンなので、 そういう場合にはそれらをまとめた型を作りましょう。 そうすれば、Option型で置き換え可能になります。</p>
<h4 id="optionの生成">Optionの生成</h4>
<p>Option型の値を生成するためには、Optionモジュールの関数・プロパティを使用します。 Option.Some/Option.None以外に、Option.Createという関数により、nullの場合はNoneとして、それ以外の場合はSomeとしてOptionオブジェクトを生成できます。</p>
<h4 id="クエリ式">クエリ式</h4>
<p>Option型はクエリ式で使うこともできます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs">from a <span class="kw">in</span> <span class="fu">F1</span>() <span class="co">// Option[int]を返す関数F1</span>
from b <span class="kw">in</span> <span class="fu">F2</span>() <span class="co">// Option[int]を返す関数F2</span>
from c <span class="kw">in</span> <span class="fu">F3</span>() <span class="co">// Option[string]を返す関数F3</span>
select c + (a + b)</code></pre>
<p>F1の結果を捨てる場合、&amp;&amp;演算子を使うことで余分な変数名の導入を避けることでできます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="co">// F1の結果は捨て、F2の結果のみ使う</span>
from a <span class="kw">in</span> <span class="fu">F1</span>() &amp;&amp; <span class="fu">F2</span>()
from c <span class="kw">in</span> <span class="fu">F3</span>()
select c + a</code></pre>
<p>ただし、これができるのは&amp;&amp;の両辺の型が同じである時のみです。 もし型が違う場合は、AndThenメソッドが使えます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="co">// F1の結果は捨て、F3の結果のみ使う</span>
from c <span class="kw">in</span> <span class="fu">F1</span>().<span class="fu">AndThen</span>(() =&gt; <span class="fu">F3</span>()) <span class="co">// もしくは単に F1().AndThen(F3)</span>
from b <span class="kw">in</span> <span class="fu">F2</span>()
select c + b</code></pre>
<p>これらのイディオムは、クエリ式内で値を捨てることができないC#では重要です。</p>
<p>クエリ式は、「一つでも失敗したら全体として直ちに失敗する」ことを表現しますが、||演算子を使うことで「一つでも成功したら全体として直ちに成功する」ことも表現できます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">return</span> <span class="fu">F1</span>() || <span class="fu">F2</span>() || <span class="fu">F3</span>().<span class="fu">Map</span>(<span class="dt">int</span>.<span class="fu">Parse</span>);</code></pre>
<p>この場合、すべての戻り値の型が同じである必要があります。</p>
<p>null合体演算子のオーバーロードが可能であれば、GetOrElseメソッドの代わりにそちらを使うことができるようになるのですが、 現在のC#はこれを許していないため、GetOrElseメソッドを使用する必要があります。 また、null合体演算子の連続<code>opt1 ?? opt2 ?? opt3 ?? defaultValue</code>を実現するためには、<code>(opt1 || opt2 || opt3).GetOrElse(() =&gt; defaultValue)</code>のように記述する必要があります。 defaultValue部分が単純な値の場合(生成コストが低く、副作用を起こすような計算ではない場合)、<code>GetOrElse(() =&gt; defaultValue)</code>の代わりに、<code>GetOr(defaultValue)</code>としてもいいでしょう。</p>
<h3 id="result型">Result型</h3>
<p>Option型は、失敗の原因を保持することができません。 Result型では、失敗の原因も保持することができます。</p>
<p>Option型同様、クエリ式の対象にすることもできますが、Option型では対応していた<code>where</code>には対応していません。 また、失敗側の型は統一する必要があります。</p>
<h4 id="failureの操作">Failureの操作</h4>
<p>Result型はOption型と違い、失敗の原因を保持することができます。 失敗側の値に対する操作を行いたい場合もあるため、これに対応しています。 失敗側の値に対して操作を行いたい場合は、成功側の操作に、サフィックス「Failure」を付けます。</p>
<p>例えば、失敗側の結果に対してMapが行いたい場合は、</p>
<pre class="sourceCode cs"><code class="sourceCode cs">res.<span class="fu">MapFailure</span>(e =&gt; e.<span class="fu">ToString</span>());</code></pre>
<p>のように記述します。</p>
<p>失敗側に対してクエリ式が使いたい場合は、SwapResultを呼び出すことで成功と失敗を入れ替えることで一応実現できます。 クエリ式による操作が終わったら、再びSwapResultを呼び出してください。</p>
<h3 id="seq型seqモジュール">Seq型/Seqモジュール</h3>
<p>Seq[T]は、Tのシーケンスを表します。</p>
<p>関数を引数に渡す高階関数のうち、インデックスを取るバージョンはWithIndexで終わります。 例えば、MapWithIndexは<code>(T, int) → U</code>という関数を受け取り、第二引数に現在の要素のインデックスが渡されてきます。</p>
<p>失敗する可能性のある関数<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup>に対しては、Optionを返すバージョンを提供しています。 Optionを返すバージョンの関数は、Tryから始まります。 例えば、Findは要素が見つからなかった場合に例外を投げますが、TryFindはNoneを返します。</p>
<h4 id="optionを含むシーケンスの変換">Optionを含むシーケンスの変換</h4>
<p>Optionのシーケンスに対する2つの関数、SequeneとOnlySomeを提供しています。</p>
<p>Sequenceは、OptionのシーケンスがSomeのみを含む場合にSomeをシーケンスの外側にくくり出します。 一つでもNoneが含まれていた場合、Noneとなります。 例えば、<code>{ Some(1), Some(2), Some(3) }</code>とあった場合、<code>Some { 1, 2, 3 }</code>となり、 <code>{ Some(1), Some(2), None }</code>とあった場合、<code>None</code>になります。</p>
<p>OnlySomeは、OptionのシーケンスからSomeの要素のみを集め、Someを取り除きます。 例えば、<code>{ Some(1), Some(2), None, Some(3) }</code>とあった場合、<code>{ 1, 2, 3 }</code>となります。</p>
<h4 id="resultを含むシーケンスの変換">Resultを含むシーケンスの変換</h4>
<p>Optionを含むシーケンスの変換同様の操作が、Resultに対しても提供されています。 Sequenceに対してはSequenceSuccess/SequenceFailureが、OnlySomeに対してはOnlySuccess/OnlyFailureがそれぞれ対応します。</p>
<h4 id="nullを含みうるシーケンスの変換">nullを含みうるシーケンスの変換</h4>
<p>MapOption関数を使うことで、nullを含みうるシーケンスを、Optionのシーケンスに変換できます。</p>
<p>参照型の場合は<code>Seq[T] → Seq[Option[T]]</code>ですが、null許容型の場合<code>Seq[T?] → Seq[Option[T]]</code>と、 null許容型が取り除かれることに注意してください。</p>
<p>同様に、MapResult関数を使うことで、nullを含みうるシーケンスをResultのシーケンスに変換できます。 この際、nullの場合は<code>Result.Failure(Unit)</code>に変換されます。</p>
<h4 id="クエリ式の提供">クエリ式の提供</h4>
<p>シーケンスはクエリ式も提供しています。 LINQ to Objectsが提供しているクエリ式はすべて使用可能です。</p>
<h4 id="ienumerableについて">IEnumerableについて</h4>
<p>IEnumerable[T]に対してもいくつか拡張メソッドを定義していますが、シーケンスに比べると限定的です。</p>
<p>基本的には、IEnumerable[T]は使わず、Seq[T]を使います。 ToSeqメソッドによって、IEnumerable[T]をシーケンスに変換できます。</p>
<h3 id="choice型">Choice型</h3>
<p>Choice型は、択一を表す型です。 Result型に似ていますが、Result型が「成功」と「失敗」という風に各型パラメータに意味を与えているのに対して、 Choice型は各型パラメータを平等に扱います。 そのため、Result型よりもより抽象度の高い型と言えます。 また、現状では16個までの型パラメータを持つことが出来ます。</p>
<p>Choice型に対して可能な操作はあまりありません。 基本的にはMatchメソッドを使うことになります。</p>
<pre class="sourceCode cs"><code class="sourceCode cs">Choice&lt;<span class="dt">int</span>, <span class="dt">string</span>&gt; c = ...
c.<span class="fu">Match</span>(
  i =&gt; ...,
  str =&gt; ...);</code></pre>
<h3 id="createモジュール">Createモジュール</h3>
<p>Createモジュールは、LangExtやC#の標準ライブラリで扱うことのできる様々な型の値を生成するための関数を提供します。</p>
<p>基本的には、<code>モジュール名.Create</code>というメソッドを提供している場合、<code>Create.型名</code>という関数を提供しています。 例えば、<code>Seq.Create</code>に対して<code>Create.Seq</code>を、<code>TupleModule.Create</code>に対して<code>Create.Tuple</code>を提供しています。 この例からわかるように、Createモジュールの関数を使った方が統一性のある記述ができますので、CreateメソッドではなくCreateモジュールの使用をお勧めします。</p>
<h3 id="tuplemoduleモジュール">TupleModuleモジュール</h3>
<p>TupleModuleモジュールは、C#標準のタプルを使いやすくするための拡張メソッドを提供します。</p>
<p>C#標準のタプルは、7要素までしか自然に扱うことができませんが、TupleModuleモジュールを使うことで型の記述以外は16要素まで自然に扱うことができるようになります。 例えば、標準ライブラリでは16要素タプルの15要素目にアクセスするためには<code>tpl.Rest.Rest.Item1</code>と記述する必要がありますが、LangExtを使うと<code>tpl._15()</code>と書けます。 n要素タプルには<code>_1(), _2(), ..., _n()</code>までの拡張メソッドのほか、1番目と2番目の要素に対しては、<code>Fst()</code>と<code>Snd()</code>という拡張メソッドも用意しています。</p>
<p>標準ライブラリの範囲では、生成も9要素以上はコンストラクタを使う必要があるため、非常に面倒です。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> tpl = <span class="kw">new</span> Tuple&lt;T1, T2, ..., T7, Tuple&lt;T8, T9, ..., T14, Tuple&lt;T15, T16&gt;&gt;&gt;(
    t1, t2, ..., t7, <span class="kw">new</span> Tuple&lt;T8, T9, ..., T14, Tuple&lt;T15, T16&gt;&gt;(
        t8, t9, ..., t14, Tuple.<span class="fu">Create</span>(t15, t16)));</code></pre>
<p>LangExtでは、これもとても簡単に記述できます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="co">// TupleModule.Createでも可</span>
<span class="dt">var</span> tpl = Create.<span class="fu">Tuple</span>(t1, t2, ..., t16);</code></pre>
<p>ほかにも、タプルの擬似的なパターンマッチや、指定要素に対するMapなどが可能です。</p>
<p>C#ではそもそもタプルを多用すべきではありません(無名型が使えるのであればそちらを使うといいでしょう)。 このモジュールは自動生成や、次に説明するFuncモジュールのために実装されています。 このモジュールで扱えるタプルの要素数が16までなのは、標準のFuncデリゲートが16引数までしか対応していないためです。</p>
<h3 id="funcモジュール">Funcモジュール</h3>
<p>Funcモジュールは、Funcデリゲートの機能を強化する関数を提供します。</p>
<p>このモジュールには、複数引数の関数「(T1, ..., Tn) → U」、タプル関数「T1 * ... * Tn → U」、カリー化関数「T1 → ... → Tn → U」の相互変換を行う関数を提供しています。 以降ではT1とT2を受け取ってUを返す関数のみ記載していますが、T16まですべて対応しています。</p>
<h4 id="複数引数関数とカリー化関数の相互変換">複数引数関数とカリー化関数の相互変換</h4>
<p>複数引数関数をカリー化関数に変換する関数<code>((T1, T2) → U) → (T1 → T2 → U)</code>を、Curryという名前で提供しています。拡張メソッド版に、Curriedも提供しています。 これの逆操作<code>(T1 → T2 → U) → ((T1, T2) → U)</code>を、Uncurryという名前で提供し、拡張メソッド版としてUncurriedも提供しています。</p>
<p>CurryしてUncurryすると、意味としては何もしていないのと同じです。</p>
<h4 id="タプル関数とカリー化関数の相互変換">タプル関数とカリー化関数の相互変換</h4>
<p>タプル関数をカリー化関数に変換する関数<code>(T1 * T2 → U) → (T1 → T2 → U)</code>を、CurryXという名前で提供しています。拡張メソッド版に、CurriedXも提供しています。 これの逆操作<code>(T1 → T2 → U) → (T1 * T2 → U)</code>を、UncurryXという名前で提供し、拡張メソッド版としてUncurriedXも提供しています。 サフィックスとして使われているXは、タプルを表すアスタリスクが由来です<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup>。</p>
<p>CurryXしてUncurryXすると、意味としては何もしていないのと同じです。</p>
<h4 id="複数引数関数とタプル関数の相互変換">複数引数関数とタプル関数の相互変換</h4>
<p>複数引数関数をタプル関数に変換する関数<code>((T1, T2) → U) → (T1 * T2 → U)</code>を、Tupleという名前で提供しています。拡張メソッド版に、Tupledも提供しています。 これの逆操作<code>(T1 * T2 → U) → ((T1, T2) → U)</code>を、Untupleという名前で提供し、拡張メソッドとしてUntupledも提供しています。</p>
<p>TupleしてUntupleすると、意味としては何もしていないのと同じです。</p>
<h4 id="option型を返す関数への変換">Option型を返す関数への変換</h4>
<p>以降では、Tを受け取ってUを返す関数のみ記載していますが、 T16までの複数引数関数すべてに対応しています(カリー化関数やタプル関数には対応していないので、これらの関数に使いたい場合は、変換関数で複数引数関数に変換する必要があります)。</p>
<p>nullを返しうる関数<code>T → U</code>を、<code>T → Option[U]</code>に変換する関数を、NullToOptionFuncという名前で提供しています。 この関数は、渡された関数の結果がnullだった場合にNoneとして返し、それ以外の場合はSomeでその値を包んで返します。 Uにclass制約が付いた形で提供されるほか、Uにstruct制約が付いた形で<code>T → U?</code>に対して、<code>T → Option[U]</code>に変換するバージョンも提供しています。 後者の場合、null許容型<code>U?</code>がnullを許容しない型<code>Option[U]</code>に変化する点に注意してください(nullはNoneで表されるため、不要になります)。</p>
<p>例外を投げうる関数<code>T → U</code>を、<code>T → Option[U]</code>に変換する関数を、ExnToOptionFuncという名前で提供しています。ExnはF#(もしくはOCaml)由来の短縮です。 この関数は、渡された関数が例外を投げた場合にNoneとして返し、それ以外の場合はSomeでその値を包んで返します。</p>
<p>上記2つを同時に行う関数を、ToOptionFuncという名前で提供しています。</p>
<p>これらの逆操作は提供していません。</p>
<h4 id="result型を返す関数への変換">Result型を返す関数への変換</h4>
<p>以降では、Tを受け取ってUを返す関数のみ記載していますが、 T16までの複数引数関数すべてに対応しています(カリー化関数やタプル関数には対応していないので、これらの関数に使いたい場合は、変換関数で複数引数関数に変換する必要があります)。</p>
<p>nullを返しうる関数<code>T → U</code>を、<code>T → Result[U, Unit]</code>に変換する関数を、NullToResultFuncという名前で提供しています。 この関数は、渡された関数の結果がnullだった場合にFailureとして返し、それ以外の場合はSuccessでその値を包んで返します。 Uにclass制約が付いた形で提供されるほか、Uにstruct制約が付いた形で<code>T → U?</code>に対して、<code>T → Result[U, Unit]</code>に変換するバージョンも提供しています。 後者の場合、null許容型<code>U?</code>がnullを許容しない型<code>Result[U, Unit]</code>に変化する点に注意してください(nullはFailureで表されるため、不要になります)。</p>
<p>例外を投げうる関数<code>T → U</code>を、<code>T → Result[U, Exception]</code>に変換する関数を、ExnToResultFuncという名前で提供しています。ExnはF#(もしくはOCaml)由来の短縮です。 この関数は、渡された関数が例外を投げた場合にFailureで例外を包んで返し、それ以外の場合はSuccessでその値を包んで返します。</p>
<p>上記2つを同時に行う関数を、ToResultFuncという名前で提供しています。 nullを返したことを表現するために、NullResultExceptionという名前の例外クラスを使っています。</p>
<p>これらの逆操作は提供していません。</p>
<h4 id="関数型スタイルの関数からoopスタイルの関数への変換とその逆">関数型スタイルの関数から、OOPスタイルの関数への変換と、その逆</h4>
<p>以降では、T1, T2を受け取ってUを返す関数のみ記載していますが、 T16までの複数引数関数すべてに対応しています。</p>
<p>多くのオブジェクト指向プログラミング言語では、ヘルパメソッドの第一引数にレシーバ相当のオブジェクトを置くスタイルがよく使われます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">static</span> <span class="kw">class</span> Objective
{
    <span class="kw">public</span> <span class="kw">static</span> Hoge <span class="fu">F</span>(Piyo self, Foo arg1, Bar arg2) ...
}</code></pre>
<p>C#の拡張メソッドは、第一引数に「this」を付けることでまさに第一引数をレシーバのように扱う記述が可能になる機能です。</p>
<p>それに対して、関数プログラミングでは、関数をカリー化した上で最後の引数にレシーバ相当のオブジェクトを置くスタイルがよく使われます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">static</span> <span class="kw">class</span> Functional
{
    <span class="kw">public</span> <span class="kw">static</span> <span class="kw">readonly</span> Func&lt;Foo, Func&lt;Bar, Func&lt;Piyo, Foo&gt;&gt;&gt; F = arg1 =&gt; arg2 =&gt; self =&gt; ...
}</code></pre>
<p>このスタイルではレシーバ相当のオブジェクトを一番最後に指定できるため、他の(固定的な)引数をあらかじめ与えておく、という方法が取れます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> f = Functional.<span class="fu">F</span>(arg1)(arg2);
...
<span class="dt">var</span> res = <span class="fu">f</span>(self);</code></pre>
<p>リストなどでは、レシーバ以外の引数はレシーバよりも固定的であることが多くあるため、非常に便利です。</p>
<p>しかし、これら2つのスタイルを常に用意しておくのは現実的ではありません。 そのため、LangExtではこれらのスタイルを相互変換するために、ToFunctionalとToObjectiveという関数を用意しています。</p>
<p>OOPLスタイルの関数Fに対して、ToFunctionalを呼び出すと、カリー化しつつ第一引数を最後に持って行った関数に変換できます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> res1 = Objective.<span class="fu">F</span>(self, arg1, arg2);

<span class="dt">var</span> f = Objective.<span class="fu">F</span>.<span class="fu">ToFunctional</span>();
<span class="dt">var</span> res2 = <span class="fu">f</span>(arg1)(arg2)(self);</code></pre>
<p>関数プログラミングスタイルの関数Fに対して、ToObjectiveを呼び出すと、アンカリー化しつつ最後の引数を最初に持って行った関数に変換できます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> res1 = Functional.<span class="fu">F</span>(arg1)(arg2)(self);

<span class="dt">var</span> f = Functional.<span class="fu">F</span>.<span class="fu">ToObjective</span>();
<span class="dt">var</span> res2 = <span class="fu">f</span>(self, arg1, arg2);</code></pre>
<p>ToFunctionalしてToObjectiveする、もしくはToObjectiveしてToFunctionalすると、元の関数に戻ります。</p>
<h3 id="applyモジュール">Applyモジュール</h3>
<p>Applyモジュールは、OptionやResultに対して関数を適用できる機能を提供します。</p>
<p>通常、OptionやResultに対して関数を適用するには、Bind関数やクエリ式を使用する必要があります。 これは、束縛を含む複雑な関数適用には便利ですが、単に<code>(T → U)</code>から<code>M[T] → M[U]</code>に変換が必要になるだけの関数適用にはオーバースペックです。 そのような単純な関数適用には、Applyモジュールを使用します。</p>
<p>次のサンプルは複数のOption（o1, o2, ..., o16）に対してfuncを適用しています。</p>
<pre class="sourceCode cs"><code class="sourceCode cs">Apply.<span class="fu">To</span>(o1, o2, ..., o16).<span class="fu">By</span>(func)</code></pre>
<p>funcの型は、To関数に渡される引数の型によって決定されます。 例えば、To関数に渡される引数の型が<code>(Option[string], Option[int])</code>だった場合、By関数に渡す関数の型は<code>(string, int) → T</code>になります。</p>
<p><code>Result[T, U]</code>のように複数の型引数が存在する場合、To関数に渡す<code>Result[T, U]</code>の型パラメータ<code>U</code>は、すべてが同一である必要があります。</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Match関数で名前付き引数を使うアイディアは、<a href="https://twitter.com/koropicot/status/315132868915523586">ころくんのつぶやき</a>から借りています。<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>失敗する可能性のある関数は、LangExt.Unsafe名前空間以下で定義しています。 そのため、これらを使用する場合はLangExt.Unsafe名前空間をusingする必要があります。<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>サフィックスのXがタプルを表すアスタリスクから来ている、というのは、こじつけの理由で、これに至るまでに紆余曲折を経ています。 当初は、<code>(T1 * T2 → U) → (T1 → T2 → U)</code>をCurry、<code>(T1 → T2 → U) → (T1 * T2 → U)</code>をUncurryにしようとしていましたが、 Curryは引数の型の違うオーバーロードとして実現できるものの、Uncurryは戻り値の型が違うだけになるため、別の名前が必要でした。</p>
<p>これにUncurry2と名前を付けてしまうと、紛らわしい(2引数版、2要素タプル版と勘違いしてしまう)という懸念があり、早々に却下されました。 Tupleという名前も考慮しましたが、これでは対称性が取れないという別の問題が生じます。 他の似たようなメソッドはCurryに対してUncurry、Tupleに対してUntupleとなっているため、ここだけCurryに対してTupleを採用するのは統一性がありません。</p>
<p>そこで、CurryとUncurryを基本に、意味のない語を付ける案に至りました。 候補としてあがったものは、XやZ、アンダースコアなどです。 Xを選んだのは、Xがタプルを表すアスタリスクに見えるから、という由来として挙げた理由からです。</p>
<p>Xを選んだものの、プレフィックスにするかサフィックスにするかは迷いました。 正直、こじつけで理由はあるものの、意味のない語であるため、どうでもよかったのです。 ただ、Xの後に母音が来ると、そのまま読めてしまうのが微妙な感じがしたので、Xuncurry(残カレー？)ではなく、UncurryXの方が良さそうでした。 こういう経緯を経て、タプル関数とカリー化関数の相互変換関数の名前がCurryXとUncurryXに決まりました。<a href="#fnref3">↩</a></p></li>
</ol>
</div>
<hr>
<div id="footer">
    <a href="index.html">index</a>
</div>
</body>
</html>
