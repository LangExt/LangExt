<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
    <a href="index.html">index</a>
</div>
<hr>
<h1 id="関数合成">関数合成</h1>
<p>LangExtでは関数合成のために、Chainというメソッドを提供しています。 ここでは、そのほかの方法ではなく、Chainのみを提供した理由を説明します。</p>
<h2 id="関数合成とは">関数合成とは</h2>
<p>関数fとgがあった時、fの戻り値の型とgの引数の型が一致した場合に限って、この2つの関数を合成することが出来ます。 例えば、stringを受け取ってDateTimeを返す関数fと、DateTimeを受け取ってintを返す関数gがあった場合、 LangExtでは以下のように2つを合成した関数hを作れます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> h = Func.<span class="fu">Chain</span>(f, g); <span class="co">// string -&gt; int</span></code></pre>
<p>Func.Chainは拡張メソッドになっているため、fがFuncデリゲートの場合は</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> h = f.<span class="fu">Chain</span>(g);</code></pre>
<p>と書くこともできます。</p>
<h2 id="関数合成の実装方法">関数合成の実装方法</h2>
<p>関数合成の実装には、様々な方法が考えられます。</p>
<h3 id="演算子のオーバーロード">演算子のオーバーロード</h3>
<p>まず、演算子のオーバーロードが考えられます。 しかし、C#ではデリゲートに対して演算子を定義することが出来ないため、 演算子のオーバーロードを使う場合、Funクラスなどの独自型を作る必要が出てきます。</p>
<p>また、classは変位指定(in/out)ができないので、Funcデリゲートよりもある点では劣ったものになってしまいます。</p>
<p>LangExtでFunのようなクラスを作った場合、それに付随して生成しなければならないものも多くなるため、 この方針はLangExtに適していないと判断し、却下しました。</p>
<h3 id="compose">Compose</h3>
<p>次に、Composeというメソッドを使う、という案です。 Haskellで関数合成と言うと、<code>f(g x)</code>のfとgを<code>f.g</code>と合成することです。 LangExtのChainとはfとgの関係が逆転していることに注意してください。 LangExtでは、<code>g.Chain(f)</code>となります。</p>
<p>Scalaでは、この関数合成を<code>compose</code>というメソッドとして提供しています。 これをそのまま採用し、Composeというメソッドを実装してもよかったのですが、 この方式では関数の合成を連続で行おうとした場合に、Composeの呼び出しをネストする必要があります。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> f = Func.<span class="fu">Compose</span>(f4, Func.<span class="fu">Compose</span>(f3, Func.<span class="fu">Compose</span>(f2, f1)));</code></pre>
<p>これは非常に面倒なうえに分かりにくいので、却下しました。</p>
<h3 id="andthen">AndThen</h3>
<p>ScalaはandThenという名前で<code>compose</code>でのfとgを入れ替えたメソッドも提供しています。 これを採用すると、上の例はわかりやすく書けるようになります。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> f = f1.<span class="fu">AndThen</span>(f2).<span class="fu">AndThen</span>(f3).<span class="fu">AndThen</span>(f4);</code></pre>
<p>大分改善されましたが、いちいちAndThenと書くのが面倒です。</p>
<h3 id="chain">Chain</h3>
<p>上記のAndThenでもよかったのですが、T4 Templateによる生成を活用することでさらに便利な記述が可能になります。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> f = Func.<span class="fu">AndThen</span>(f1, f2, f3, f4);</code></pre>
<p>これは、可変長引数では実現できません。 なぜなら、f1の戻り値の型とf2の引数の型、f2の戻り値の型とf3の引数の型、f3の戻り値の型とf4の引数の型が、 それぞれ一致している必要があるからです。 可変長引数で実現しようとした場合、全ての関数の引数の型と戻り値の型が一致している必要があり、 使い道のない関数になってしまいます。</p>
<p>これをT4 Templateを使って「前の関数の戻り値の型と同じ引数の型を持つ関数しか渡せない」ことを実現しています。 擬似的に可変長引数を実現したため、AndThenではちょっと意味が通らなくなってしまいました。 そこで、これを「関数の連鎖」ととらえ、Chainという名前を使うようにしました。</p>
<p>T4 Templateで生成している関係上、16引数までしか対応していませんが、 それ以上の個数の関数を合成したい場合は、Chainが拡張メソッドであることを利用します。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> f = Func.<span class="fu">Chain</span>(f1, f2, ..., f16).<span class="fu">Chain</span>(f17, f18, ...</code></pre>
<p>ここまで大量の関数を合成する場合、設計を疑った方がいいかもしれませんが。</p>
<h2 id="func.chain形式と拡張メソッド形式の使い分け">Func.Chain形式と拡張メソッド形式の使い分け</h2>
<p>Chainは拡張メソッドとして実装されているため、<code>f.Chain(g)</code>と<code>Func.Chain(f, g)</code>という2通りの書き方ができます。 これらの使い分けは、最初の関数がFuncデリゲートかどうかと、合成する関数が1つかどうかで判断します。</p>
<p>最初の関数がFuncデリゲートではない場合、拡張メソッド形式はそのままでは使えません。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> f = DateTime.<span class="fu">Parse</span>.<span class="fu">Chain</span>(...); <span class="co">// コンパイルエラー</span></code></pre>
<p>これは、Func.ChainがFuncデリゲートの拡張メソッドとしてしか定義されておらず、 <code>DateTime.Parse</code>は単なるstaticメソッドでありFuncデリゲートではないのが原因です。 これをいちいちFuncデリゲートに変換するのは面倒なので、 最初の関数がFuncデリゲートではない場合は、<code>Func.Chain</code>形式を使うのがいいでしょう。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> f = Func.<span class="fu">Chain</span>(DateTime.<span class="fu">Parse</span>, ...);</code></pre>
<p>最初の関数がFuncデリゲートかつ、 合成する関数が1つ(つまり2つの関数を合成する)場合は、拡張メソッド形式を使います。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> h = f.<span class="fu">Chain</span>(g);</code></pre>
<p>合成する関数が2つよりも多い場合は、<code>Func.Chain</code>形式を使います。 これは、単に分かりやすさのためです。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">var</span> f = Func.<span class="fu">Chain</span>(f1, f2, f3);</code></pre>
<p>ただし、合成したい関数が16を超える場合は、拡張メソッド形式で繋ぐ必要があります。</p>
<p>また、合成する関数をその場でラムダ式として書く場合で、その中身が長くなる場合は、 拡張メソッド形式で記述した方が分かりやすくなるかもしれません。</p>
<hr>
<div id="footer">
    <a href="index.html">index</a>
</div>
</body>
</html>
