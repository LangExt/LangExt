<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
    <a href="index.html">index</a>
</div>
<hr>
<h1 id="seqシーケンス">Seq(シーケンス)</h1>
<p>LangExtでは、IEnumerable[T]の代わりとなる型として、Seq[T]を提供しています。 ここでは、なぜIEnumerable[T]の代わりにSeq[T]という別の型を用意したのかを中心に説明します。 また、LINQを捨てた理由についても説明します。</p>
<p>この設計選択に納得できない場合、LangExtを直接使うのは避けた方がいいでしょう。 LangExtからフォークして、独自のライブラリを作るなどしてください。</p>
<h2 id="seqとienumerableの違い">SeqとIEnumerableの違い</h2>
<p>Seq[T]はIEnumerable[T]を継承しているため、IEnumerable[T]が必要な場面ではいつでもSeq[T]も使えます。 LangExtでは、IEnumerable[T]よりもSeq[T]の使用を推奨しています。 以降ではその理由を説明します。</p>
<h3 id="seqtの方が名前が短い">Seq[T]の方が名前が短い</h3>
<p>IEnumerable[T]は名前が長いという大きな欠点を抱えています。 長い型名はタイプが面倒なだけでなく、画面を占有するため、読みにくく理解しにくいコードになりがちです。 IEnumerable[T]を2つ受け取り、IEnumerable[T]を返すような関数Fを考えてみると、 関数のシグネチャだけでかなりの字数を消費してしまいます。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">static</span> IEnumerable&lt;T&gt; <span class="fu">F</span>(IEnumerable&lt;T&gt; xs, IEnumerable&lt;T&gt; ys)</code></pre>
<p>それに対して、Seq[T]はIEnumerable[T]の半分の文字数で済むため、字数はそれほど消費しません。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">static</span> Seq&lt;T&gt; <span class="fu">F</span>(Seq&lt;T&gt; xs, Seq&lt;T&gt; ys)</code></pre>
<h3 id="seqtの方が出来る操作が多い">Seq[T]の方が出来る操作が多い</h3>
<p>LangExtではSeq[T]の方を使ってもらえるように、IEnumerable[T]に対して出来る操作よりも、 Seq[T]に対してできる操作の方が充実しています。</p>
<p>Seq[T]のみに対してできる操作には、例えば以下の関数があります。</p>
<ul>
<li>Init/Repeat</li>
<li>Size/Len/Count</li>
<li>Exists/Forall</li>
<li>Fold/FoldBack/ScanBack/TryReduce/TryReduceBack</li>
<li>Filter/Partition</li>
<li>Reverse</li>
<li>Sort/RevSort</li>
<li>TryFind/TryPick</li>
</ul>
<p>これらの関数が使いたい場合、<code>ToSeq</code>メソッドでSeq[T]に変換してください。</p>
<h3 id="ienumerabletを捨てたことによる欠点">IEnumerable[T]を捨てたことによる欠点</h3>
<p>IEnumerable[T]ではなく、Seq[T]という新しい型を中心に据えたことによる欠点もあります。 それは、yield構文がそのままでは使えなくなるという点です。</p>
<p>C#のyield構文は、IEnumerable[T]/IEnumerator[T]と切り離すことが出来ません。 そのため、現状のLangExtではIEnumerable[T]に対してyieldで実装したものをSeq[T]でラップすることで実装しています。</p>
<h2 id="標準クエリ演算子からの解放">標準クエリ演算子からの解放</h2>
<p>LangExtでは、LINQ to Objectsに関して <a href="http://msdn.microsoft.com/ja-jp/library/vstudio/bb397896.aspx">標準クエリ演算子</a> を捨て、独自の関数名を提供しています。 以降では、なぜ標準クエリ演算子を捨てたのかについて説明します。</p>
<h3 id="sqlに合わせたメソッド名">SQLに合わせたメソッド名</h3>
<p>標準クエリ演算子は、各メソッド名にSQL由来の名前を付けています。 例えば、フィルター処理はWhere、射影操作にはSelectといった具合です。</p>
<p>これは、SQLを扱うことが多かった業務プログラマをLINQの世界に引き込みやすくした、 というよかった点もありますが、あまりに短期的なメリットしか見ていないように感じます。</p>
<p>全てをSQLに合わせることはできないため、無理のある名前を付けざるを得ない例(SelectMany)もあります。</p>
<p>それだけならまだましで、SQLと異なる名前を付けている例もあります。 例えば、SQLで結果セットの連結には<code>UNION ALL</code>を使いますが、標準クエリ演算子では<code>Concat</code>になっています。 他にも、SQLでは<code>AVG</code>なのに標準クエリ演算子では<code>Average</code>となっている例があります。</p>
<h3 id="名前の使い回し">名前の使い回し</h3>
<p>標準クエリ演算子は、オーバーロード機構を前提にして名前を使い回ししています。 例えば、述語を満たす要素が1つでもあるかどうかを調べる用途と、 そもそも要素が1つでも存在するかどうかを調べる用途に、<code>Any</code>という名前を使っています。 他にも、Aggregate(初期値を与えるか先頭の要素を使うか)、Count(長さを調べるか述語を満たす要素を数え上げるか)があります。</p>
<p>また、SelectやWhereなど、要素のインデックスを追加で取るオーバーロードを用意している関数もあります。</p>
<p>別の役割を持ったものには別の名前を付けるべきです。 標準クエリ演算子は名前を使い回しすぎでしょう。</p>
<p>LangExtでは、それぞれに別の名前を用意しています。 標準クエリ演算子のAnyはLangExtのExistsとIsNotEmptyに、AggregateはFoldとReduce(Unsafe名前空間)に、 CountはSize/LenとCountにそれぞれ対応します。 また、要素のインデックスを追加で取るバージョンは、メソッド名の後ろにWithIndexを付けています。</p>
<h3 id="langextのシーケンス操作関数の語彙">LangExtのシーケンス操作関数の語彙</h3>
<p>これらの問題を解決するため、LangExtでは主にF#から語彙を借りています。 F#の語彙はHaskellやOCaml、Scalaともある程度一致しているため、LINQの語彙よりも応用範囲が広くなります。</p>
<p>Optionを返すような関数にはTryを付けるようにしており、 Try無しの(例外を投げうる)関数はUnsafe名前空間内に別定義してあります。</p>
<h3 id="クエリ式の提供">クエリ式の提供</h3>
<p>LangExtでは、LINQのうち標準クエリ演算子は捨てましたが、クエリ式は使えるようになっています。 Seq[T]も、クエリ式の対象にすることが可能です。</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">return</span>
    from x <span class="kw">in</span> xs
    from y <span class="kw">in</span> ys
    select x + y;</code></pre>
<p>クエリ式をサポートするためのメソッドは補完候補に表示されないようになっているため、 メソッド形式でそれらのメソッドを使うことは通常ありません。</p>
<hr>
<div id="footer">
    <a href="index.html">index</a>
</div>
</body>
</html>
